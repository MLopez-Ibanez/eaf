[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Manuel López-Ibáñez. Author, maintainer. Marco Chiarandini. Author. Carlos Fonseca. Author. Luís Paquete. Author. Thomas Stützle. Author. Mickaël Binois. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Manuel López-Ibáñez, Luís Paquete, Thomas Stützle. Exploratory Analysis Stochastic Local Search Algorithms Biobjective Optimization. T. Bartz-Beielstein, M. Chiarandini, L. Paquete, M. Preuss, editors, Experimental Methods Analysis Optimization Algorithms, pages 209–222. Springer, Berlin, Germany, 2010. doi: 10.1007/978-3-642-02538-9_9","code":"@InCollection{,   title = {Exploratory Analysis of Stochastic Local Search Algorithms in Biobjective Optimization},   author = {Manuel López-Ibáñez and Luis Paquete and Thomas Stützle},   year = {2010},   doi = {10.1007/978-3-642-02538-9_9},   booktitle = {Experimental Methods for the Analysis of Optimization Algorithms},   publisher = {Springer, Berlin, Germany},   editor = {Thomas Bartz-Beielstein and Marco Chiarandini and Luís Paquete and Mike Preuss},   pages = {209--222}, }"},{"path":"/index.html","id":"eaf-empirical-attainment-function-eaf-tools","dir":"","previous_headings":"","what":"Plots of the Empirical Attainment Function","title":"Plots of the Empirical Attainment Function","text":"[ Homepage ] [ GitHub ] Maintainer: Manuel López-Ibáñez Contributors: Manuel López-Ibáñez, Marco Chiarandini, Carlos M. Fonseca, Luís Paquete, Thomas Stützle, Mickaël Binois.","code":""},{"path":"/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Plots of the Empirical Attainment Function","text":"empirical attainment function (EAF) describes probabilistic distribution outcomes obtained stochastic algorithm objective space. R package implements plots summary attainment surfaces differences first-order EAFs. plots may used exploring performance stochastic local search algorithms biobjective optimization problems help identifying certain algorithmic behaviors graphical way. corresponding book chapter [1] explains use visualization tools illustrates examples arising practice. addition, package provides functions computing several quality metrics, hypervolume, IGD, IGD+, epsilon. Keywords: empirical attainment function, summary attainment surfaces, EAF differences, multi-objective optimization, bi-objective optimization, performance measures, performance assessment, graphical analysis, visualization. Relevant literature: Manuel López-Ibáñez, Luís Paquete, Thomas Stützle. Exploratory Analysis Stochastic Local Search Algorithms Biobjective Optimization. T. Bartz-Beielstein, M. Chiarandini, L. Paquete, M. Preuss, editors, Experimental Methods Analysis Optimization Algorithms, pages 209–222. Springer, Berlin, Germany, 2010. (chapter also available slightly extended form Technical Report TR/IRIDIA/2009-015). [ bibtex | doi: 10.1007/978-3-642-02538-9_9 | Presentation ]","code":""},{"path":"/index.html","id":"download-and-installation","dir":"","previous_headings":"","what":"Download and installation","title":"Plots of the Empirical Attainment Function","text":"eaf package implemented R. Therefore, basic knowledge R recommended make use features. first step installing eaf package install R. R installed system, two methods installing eaf package: Install within R (automatic download, internet connection required). Invoke R, Download eaf package CRAN (may also need download install first package modeltools), invoke command-line: <package> one three versions available: .tar.gz (Unix/BSD/GNU/Linux), .tgz (MacOS X), .zip (Windows). Search R documentation need help install R package system. code computing EAF available C program, require installing R R packages. Just download package source code, uncompress , look directory src/eaf. C code can used implement visualizations instead visualizations provided eaf package. Compiled executables computing EAF can found system.file(package=\"eaf\", \"bin\"). useful executable programs can found . eaf package also contains two Perl scripts may allow generate standard plots without R knowledge. See inst/scripts/eafplot/ inst/scripts/eafdiff/ package source code. scripts use eaf package internally generate plots, , hence, eaf package must installed working. wish notified bugfixes new versions, please subscribe low-volume emo-list, announcements made. [ Download eaf package CRAN ] [ Documentation ] [ Development version (GitHub) ]","code":"install.packages(\"eaf\") R CMD INSTALL <package>"},{"path":"/index.html","id":"github-development-version","dir":"","previous_headings":"","what":"GitHub (Development version)","title":"Plots of the Empirical Attainment Function","text":"wish try development version, can install executing following commands within R console:","code":"R> install.packages(\"devtools\")     R> devtools::install_github(\"MLopez-Ibanez/eaf\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Plots of the Empirical Attainment Function","text":"eaf package installed, following R commands give information: Apart main R package, source code contains following extras directory inst/ (installation, files can found directory printed R command system.file(package=\"eaf\")): scripts/eafplot : Perl script plot summary attainment surfaces. scripts/eafdiff : Perl script plot differences EAFs two input sets. extdata/ : Examples utilization programs. discussed corresponding book chapter [1]. addition, source code contains following src/: * src/eaf : C program computes empirical attainment function 2 3 dimensions. required programs, provided useful command-line utility. version based original code written Carlos M. Fonseca available http://www.tik.ee.ethz.ch/pisa/. recent version available Prof. Fonseca’s website. * src/mo-tools : Several tools working multi-objective data. information, consult README files subdirectory.","code":"library(eaf)     ?eaf     ?eafplot     ?eafdiffplot     ?read.data.sets     example(eafplot)     example(eafdiffplot) # This one takes some time"},{"path":"/index.html","id":"python","dir":"","previous_headings":"","what":"Python","title":"Plots of the Empirical Attainment Function","text":"Thanks rpy2, can use eaf package Python. complete example :","code":"import os ## Uncomment this if you suffer from this bug in cffi 1.13.0 ## https://bitbucket.org/rpy2/rpy2/issues/591/runtimeerror-found-a-situation-in-which-we #os.environ['RPY2_CFFI_MODE'] = \"API\"  # Tested with rpy2 2.9.2-1 and 3.2.6 import numpy as np from rpy2.robjects.packages import importr, isinstalled, PackageNotInstalledError from rpy2.robjects import r as R from rpy2.robjects import numpy2ri from rpy2.robjects.vectors import StrVector numpy2ri.activate() from rpy2.interactive import process_revents process_revents.start()  def install_rpackages(packages):     if not isinstance(packages, list):         packages = [ packages ]     utils = importr('utils') # import R's utility package     # Selectively install what needs to be installed.     names_to_install = [x for x in packages if not isinstalled(x)]     if len(names_to_install) > 0:         print(f\"Installing packages: {names_to_install}\")         utils.install_packages(StrVector(names_to_install), repos = \"https://cloud.r-project.org\", verbose=True)  try:     eaf = importr(\"eaf\") except PackageNotInstalledError as e:     install_rpackages(\"eaf\")     eaf = importr(\"eaf\") # Retry after install  path = R('system.file(package=\"eaf\", \"extdata\")')[0] + \"/\" alg1 = eaf.read_data_sets_(path + \"ALG_1_dat.xz\") alg1 = np.asarray(alg1) alg2 = np.asarray(eaf.read_data_sets_(path + \"ALG_2_dat.xz\"))  eaf.eafplot(alg1[:, 0:2], sets=alg1[:,2])  input(\"Press ENTER to see next plot: \")  eaf.eafdiffplot(alg1, alg2, title_left=\"A\", title_right=\"B\")"},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Plots of the Empirical Attainment Function","text":"software Copyright (C) 2011-2021 Carlos M. Fonseca, Luís Paquete, Thomas Stützle, Manuel López-Ibáñez Marco Chiarandini. program free software (software libre); can redistribute /modify terms GNU General Public License published Free Software Foundation; either version 2 License, (option) later version. program distributed hope useful, WITHOUT WARRANTY; without even implied warranty MERCHANTABILITY FITNESS PARTICULAR PURPOSE. See GNU General Public License details. IMPORTANT NOTE: Please aware fact program released Free Software excuse scientific propriety, obligates give appropriate credit! write scientific paper describing research made substantive use program, obligation scientist () mention fashion software used Methods section; (b) mention algorithm References section. appropriate citation : Manuel López-Ibáñez, Luís Paquete, Thomas Stützle. Exploratory Analysis Stochastic Local Search Algorithms Biobjective Optimization. T. Bartz-Beielstein, M. Chiarandini, L. Paquete, M. Preuss, editors, Experimental Methods Analysis Optimization Algorithms, pages 209–222. Springer, Berlin, Germany, 2010. doi: 10.1007/978-3-642-02538-9_9 Moreover, personal note, appreciate email manuel.lopez-ibanez@manchester.ac.uk citations papers referencing work can mention funding agent tenure committee.","code":""},{"path":"/reference/CPFs.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"data goal providing example use vorobT() vorobDev(). obtained fitting two Gaussian processes 20 observations bi-objective problem, generating conditional simulation GPs different locations extracting non-dominated values coupled simulations.","code":""},{"path":"/reference/CPFs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"","code":"CPFs"},{"path":"/reference/CPFs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"data frame 2967 observations following 3 variables. f1 first objective values. f2 second objective values. set indices corresponding conditional Pareto fronts.","code":""},{"path":"/reference/CPFs.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"M Binois, D Ginsbourger, O Roustant (2015). “Quantifying uncertainty Pareto fronts Gaussian process conditional simulations.” European Journal Operational Research, 243(2), 386--394. doi:10.1016/j.ejor.2014.07.032 .","code":""},{"path":"/reference/CPFs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"","code":"data(CPFs)  res <- vorobT(CPFs, reference = c(2, 200)) eafplot(CPFs[,1:2], sets = CPFs[,3], percentiles = c(0, 20, 40, 60, 80, 100),        col = gray(seq(0.8, 0.1, length.out = 6)^2), type = \"area\",        legend.pos = \"bottomleft\", extra.points = res$VE, extra.col = \"cyan\")"},{"path":"/reference/HybridGA.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of Hybrid GA on vanzyl and Richmond water networks — HybridGA","title":"Results of Hybrid GA on vanzyl and Richmond water networks — HybridGA","text":"data goal providing example use eafplot.","code":""},{"path":"/reference/HybridGA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of Hybrid GA on vanzyl and Richmond water networks — HybridGA","text":"","code":"HybridGA"},{"path":"/reference/HybridGA.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of Hybrid GA on vanzyl and Richmond water networks — HybridGA","text":"list two data frames, three columns, produced read_datasets(). $vanzyl data frame results vanzyl network $richmond data frame results Richmond network. second column filled NA","code":""},{"path":"/reference/HybridGA.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of Hybrid GA on vanzyl and Richmond water networks — HybridGA","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. http://researchrepository.napier.ac.uk/id/eprint/3044. .","code":""},{"path":"/reference/HybridGA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of Hybrid GA on vanzyl and Richmond water networks — HybridGA","text":"","code":"data(HybridGA) print(HybridGA$vanzyl) #>       V1 V2 #> 1 347.10  4 #> 2 352.06  3 #> 3 352.15  4 #> 4 344.43  5 #> 5 344.81  4 #> 6 354.79  5 #> 7 344.74  5 print(HybridGA$richmond) #>     V1 V2 #> 1  101 NA #> 2  104 NA #> 3  100 NA #> 4   97 NA #> 5   97 NA #> 6  101 NA #> 7  101 NA #> 8   99 NA #> 9   98 NA #> 10  98 NA"},{"path":"/reference/SPEA2minstoptimeRichmond.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of SPEA2 when minimising electrical cost and maximising the\nminimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","title":"Results of SPEA2 when minimising electrical cost and maximising the\nminimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"data goal providing example use eafplot.","code":""},{"path":"/reference/SPEA2minstoptimeRichmond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of SPEA2 when minimising electrical cost and maximising the\nminimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"","code":"SPEA2minstoptimeRichmond"},{"path":"/reference/SPEA2minstoptimeRichmond.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of SPEA2 when minimising electrical cost and maximising the\nminimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"data frame produced read_datasets(). second column measures time seconds corresponds maximisation problem.","code":""},{"path":"/reference/SPEA2minstoptimeRichmond.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of SPEA2 when minimising electrical cost and maximising the\nminimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. http://researchrepository.napier.ac.uk/id/eprint/3044.","code":""},{"path":"/reference/SPEA2minstoptimeRichmond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of SPEA2 when minimising electrical cost and maximising the\nminimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"","code":"data(HybridGA) data(SPEA2minstoptimeRichmond) SPEA2minstoptimeRichmond[,2] <- SPEA2minstoptimeRichmond[,2] / 60 eafplot (SPEA2minstoptimeRichmond, xlab = expression(C[E]),          ylab = \"Minimum idle time (minutes)\", maximise = c(FALSE, TRUE),          las = 1, log = \"y\", legend.pos = \"bottomright\")"},{"path":"/reference/SPEA2relativeRichmond.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of SPEA2 with relative time-controlled triggers on Richmond water\nnetwork. — SPEA2relativeRichmond","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water\nnetwork. — SPEA2relativeRichmond","text":"data goal providing example use eafplot.","code":""},{"path":"/reference/SPEA2relativeRichmond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water\nnetwork. — SPEA2relativeRichmond","text":"","code":"SPEA2relativeRichmond"},{"path":"/reference/SPEA2relativeRichmond.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water\nnetwork. — SPEA2relativeRichmond","text":"data frame produced read_datasets().","code":""},{"path":"/reference/SPEA2relativeRichmond.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water\nnetwork. — SPEA2relativeRichmond","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. http://researchrepository.napier.ac.uk/id/eprint/3044.","code":""},{"path":"/reference/SPEA2relativeRichmond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water\nnetwork. — SPEA2relativeRichmond","text":"","code":"data(HybridGA) data(SPEA2relativeRichmond) eafplot (SPEA2relativeRichmond, percentiles = c(25, 50, 75),         xlab = expression(C[E]), ylab = \"Total switches\",         xlim = c(90, 140), ylim = c(0, 25),         extra.points = HybridGA$richmond, extra.lty = \"dashed\",         extra.legend = \"Hybrid GA\")"},{"path":"/reference/SPEA2relativeVanzyl.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's\nwater network. — SPEA2relativeVanzyl","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's\nwater network. — SPEA2relativeVanzyl","text":"data goal providing example use eafplot.","code":""},{"path":"/reference/SPEA2relativeVanzyl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's\nwater network. — SPEA2relativeVanzyl","text":"","code":"SPEA2relativeVanzyl"},{"path":"/reference/SPEA2relativeVanzyl.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's\nwater network. — SPEA2relativeVanzyl","text":"data frame produced read_datasets().","code":""},{"path":"/reference/SPEA2relativeVanzyl.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's\nwater network. — SPEA2relativeVanzyl","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. http://researchrepository.napier.ac.uk/id/eprint/3044.","code":""},{"path":"/reference/SPEA2relativeVanzyl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's\nwater network. — SPEA2relativeVanzyl","text":"","code":"data(HybridGA) data(SPEA2relativeVanzyl) eafplot(SPEA2relativeVanzyl, percentiles = c(25, 50, 75),         xlab = expression(C[E]), ylab = \"Total switches\", xlim = c(320, 400),        extra.points = HybridGA$vanzyl, extra.legend = \"Hybrid GA\")"},{"path":"/reference/Vorob.html","id":null,"dir":"Reference","previous_headings":"","what":"Vorob'ev computations — vorobT","title":"Vorob'ev computations — vorobT","text":"Compute Vorob'ev threshold, expectation deviation. Also, displaying symmetric deviation function possible.  symmetric deviation function probability given target objective space belong symmetric difference Vorob'ev expectation realization (random) attained set.","code":""},{"path":"/reference/Vorob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vorob'ev computations — vorobT","text":"","code":"vorobT(x, reference)  vorobDev(x, VE, reference)  symDifPlot(   x,   VE,   threshold,   nlevels = 11,   ve.col = \"blue\",   xlim = NULL,   ylim = NULL,   legend.pos = \"topright\",   main = \"Symmetric deviation function\",   col.fun = function(n) gray(seq(0, 0.9, length.out = n)^2) )"},{"path":"/reference/Vorob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vorob'ev computations — vorobT","text":"x Either matrix data values, data frame, list data frames exactly three columns.  third column gives set (run, sample, ...) identifier. reference (numeric())  Reference point vector numerical values. VE, threshold Vorob'ev expectation threshold, e.g., returned vorobT(). nlevels number levels divided range symmetric deviation. ve.col plotting parameters Vorob'ev expectation. xlim, ylim, main Graphical parameters, see plot.default(). legend.pos position legend, see legend(). value \"none\" hides legend. col.fun function creates vector n colors, see heat.colors().","code":""},{"path":"/reference/Vorob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vorob'ev computations — vorobT","text":"vorobT returns list elements threshold, VE, avg_hyp (average hypervolume) vorobDev returns Vorob'ev deviation.","code":""},{"path":"/reference/Vorob.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Vorob'ev computations — vorobT","text":"M Binois, D Ginsbourger, O Roustant (2015). “Quantifying uncertainty Pareto fronts Gaussian process conditional simulations.” European Journal Operational Research, 243(2), 386--394. doi:10.1016/j.ejor.2014.07.032 . C. Chevalier (2013), Fast uncertainty reduction strategies relying Gaussian process models, University Bern, PhD thesis. . Molchanov (2005), Theory random sets, Springer.","code":""},{"path":"/reference/Vorob.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Vorob'ev computations — vorobT","text":"Mickael Binois","code":""},{"path":"/reference/Vorob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vorob'ev computations — vorobT","text":"","code":"data(CPFs) res <- vorobT(CPFs, reference = c(2, 200)) print(res$threshold) #> [1] 44.14062  ## Display Vorob'ev expectation and attainment function # First style eafplot(CPFs[,1:2], sets = CPFs[,3], percentiles = c(0, 25, 50, 75, 100, res$threshold),         main = substitute(paste(\"Empirical attainment function, \",beta,\"* = \", a, \"%\"),                           list(a = formatC(res$threshold, digits = 2, format = \"f\"))))   # Second style eafplot(CPFs[,1:2], sets = CPFs[,3], percentiles = c(0, 20, 40, 60, 80, 100),         col = gray(seq(0.8, 0.1, length.out = 6)^0.5), type = \"area\",          legend.pos = \"bottomleft\", extra.points = res$VE, extra.col = \"cyan\",         extra.legend = \"VE\", extra.lty = \"solid\", extra.pch = NA, extra.lwd = 2,         main = substitute(paste(\"Empirical attainment function, \",beta,\"* = \", a, \"%\"),                           list(a = formatC(res$threshold, digits = 2, format = \"f\"))))   # Now print Vorob'ev deviation VD <- vorobDev(CPFs, res$VE, reference = c(2, 200)) print(VD) #> [1] 3017.13 # Now display the symmetric deviation function. symDifPlot(CPFs, res$VE, res$threshold, nlevels = 11)  # Levels are adjusted automatically if too large. symDifPlot(CPFs, res$VE, res$threshold, nlevels = 200, legend.pos = \"none\")   # Use a different palette. symDifPlot(CPFs, res$VE, res$threshold, nlevels = 11, col.fun = heat.colors)"},{"path":"/reference/attsurf2df.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a list of attainment surfaces to a data.frame — attsurf2df","title":"Convert a list of attainment surfaces to a data.frame — attsurf2df","text":"Convert list attainment surfaces single data.frame.","code":""},{"path":"/reference/attsurf2df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a list of attainment surfaces to a data.frame — attsurf2df","text":"","code":"attsurf2df(x)"},{"path":"/reference/attsurf2df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a list of attainment surfaces to a data.frame — attsurf2df","text":"x (list()) List data.frames matrices. names list give percentiles attainment surfaces.  format returned eafplot() (internal function compute.eaf..list).","code":""},{"path":"/reference/attsurf2df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a list of attainment surfaces to a data.frame — attsurf2df","text":"data.frame many columns objectives additional column percentiles.","code":""},{"path":"/reference/attsurf2df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a list of attainment surfaces to a data.frame — attsurf2df","text":"","code":"data(SPEA2relativeRichmond) attsurfs <- eafplot (SPEA2relativeRichmond, percentiles = c(0,50,100),                      xlab = expression(C[E]), ylab = \"Total switches\",                      lty=0, pch=21, xlim = c(90, 140), ylim = c(0, 25)) attsurfs <- attsurf2df(attsurfs) text(attsurfs[,1:2], labels = attsurfs[,3], adj = c(1.5,1.5))"},{"path":"/reference/choose_eafdiffplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactively choose according to empirical attainment function differences — choose_eafdiffplot","title":"Interactively choose according to empirical attainment function differences — choose_eafdiffplot","text":"Creates plot eafdiffplot() waits user click one sides. returns rectangles give differences favour chosen side. rectangles may used interactive decision-making shown Diaz López-Ibáñez (2021) . function choose_eafdiff() may used non-interactive context.","code":""},{"path":"/reference/choose_eafdiffplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactively choose according to empirical attainment function differences — choose_eafdiffplot","text":"","code":"choose_eafdiffplot(   data.left,   data.right,   intervals = 5,   maximise = c(FALSE, FALSE),   title.left = deparse(substitute(data.left)),   title.right = deparse(substitute(data.right)),   ... )  choose_eafdiff(x, left = stop(\"'left' must be either TRUE or FALSE\"))"},{"path":"/reference/choose_eafdiffplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactively choose according to empirical attainment function differences — choose_eafdiffplot","text":"data.left, data.right Data frames corresponding input data left right sides, respectively. data frame least three columns, third one set point. See also read_datasets(). intervals (integer(1)|character())  absolute range differences \\([0, 1]\\) partitioned number intervals provided. integer provided, labels interval computed automatically. character vector provided, length taken number intervals. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. title.left, title.right Title left right panels, respectively. ... graphical parameters passed eafdiffplot(). x (matrix()) Matrix rectangles representing EAF differences (returned eafdiff() rectangles=TRUE). left (logical(1)) left=TRUE return rectangles positive differences, otherwise return negative differences differences converted positive.","code":""},{"path":"/reference/choose_eafdiffplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interactively choose according to empirical attainment function differences — choose_eafdiffplot","text":"matrix first 4 columns give coordinates two corners rectangle last column. cases, last column gives positive differences favor chosen side.","code":""},{"path":"/reference/choose_eafdiffplot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Interactively choose according to empirical attainment function differences — choose_eafdiffplot","text":"Juan Esteban Diaz, Manuel López-Ibáñez (2021). “Incorporating Decision-Maker's Preferences Automatic Configuration Bi-Objective Optimisation Algorithms.” European Journal Operational Research, 289(3), 1209--1222. doi:10.1016/j.ejor.2020.07.059 .","code":""},{"path":[]},{"path":"/reference/choose_eafdiffplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactively choose according to empirical attainment function differences — choose_eafdiffplot","text":"","code":"# \\donttest{ extdata_dir <- system.file(package=\"eaf\", \"extdata\")  A1 <- read_datasets(file.path(extdata_dir, \"wrots_l100w10_dat\")) A2 <- read_datasets(file.path(extdata_dir, \"wrots_l10w100_dat\")) if (interactive()) {   rectangles <- choose_eafdiffplot(A1, A2, intervals = 5) } else { # Choose A1   rectangles <- eafdiff(A1, A2, intervals = 5, rectangles = TRUE)   rectangles <- choose_eafdiff(rectangles, left = TRUE) } reference <- c(max(A1[, 1], A2[, 1]), max(A1[, 2], A2[, 2])) x <- split.data.frame(A1[,1:2], A1[,3]) hv_A1 <- sapply(split.data.frame(A1[, 1:2], A1[, 3]),                  hypervolume, reference=reference) hv_A2 <- sapply(split.data.frame(A2[, 1:2], A2[, 3]),                  hypervolume, reference=reference) boxplot(list(A1=hv_A1, A2=hv_A2), main = \"Hypervolume\")   whv_A1 <- sapply(split.data.frame(A1[, 1:2], A1[, 3]),                  whv_rect, rectangles=rectangles, reference=reference) whv_A2 <- sapply(split.data.frame(A2[, 1:2], A2[, 3]),                  whv_rect, rectangles=rectangles, reference=reference) boxplot(list(A1=whv_A1, A2=whv_A2), main = \"Weighted hypervolume\")  # }"},{"path":"/reference/eaf-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Computation and visualization of the empirical attainment function (EAF) for\nthe analysis of random sets in multi-criterion optimization. — eaf-package","title":"Computation and visualization of the empirical attainment function (EAF) for\nthe analysis of random sets in multi-criterion optimization. — eaf-package","text":"empirical attainment function (EAF) describes probabilistic distribution outcomes obtained stochastic algorithm objective space. package implements plots summary attainment surfaces differences first-order EAFs. plots may used exploring performance stochastic local search algorithms biobjective optimization problems help identifying certain algorithmic behaviors graphical way.","code":""},{"path":[]},{"path":"/reference/eaf-package.html","id":"data","dir":"Reference","previous_headings":"","what":"Data","title":"Computation and visualization of the empirical attainment function (EAF) for\nthe analysis of random sets in multi-criterion optimization. — eaf-package","text":"gcp2x2 Metaheuristics solving Graph Vertex Coloring Problem HybridGA Results Hybrid GA vanzyl Richmond water networks SPEA2minstoptimeRichmond Results SPEA2 minimising electrical cost maximising minimum idle time pumps Richmond water network Extras available system.file(package=\"eaf\"):","code":""},{"path":"/reference/eaf-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computation and visualization of the empirical attainment function (EAF) for\nthe analysis of random sets in multi-criterion optimization. — eaf-package","text":"Viviane Grunert da Fonseca, Carlos M. Fonseca, Andreia O. Hall (2001). “Inferential Performance Assessment Stochastic Optimisers Attainment Function.” Eckart Zitzler, Kalyanmoy Deb, Lothar Thiele, Carlos . Coello Coello, David Corne (eds.), Evolutionary Multi-criterion Optimization, EMO 2001, volume 1993 Lecture Notes Computer Science, 213--225. Springer, Heidelberg, Germany. doi:10.1007/3-540-44719-9_15 . Viviane Grunert da Fonseca, Carlos M. Fonseca (2010). “Attainment-Function Approach Stochastic Multiobjective Optimizer Assessment Comparison.” Thomas Bartz-Beielstein, Marco Chiarandini, Luís Paquete, Mike Preuss (eds.), Experimental Methods Analysis Optimization Algorithms, 103--130. Springer, Berlin, Germany. Manuel López-Ibáñez, Luís Paquete, Thomas Stützle (2010). “Exploratory Analysis Stochastic Local Search Algorithms Biobjective Optimization.” Thomas Bartz-Beielstein, Marco Chiarandini, Luís Paquete, Mike Preuss (eds.), Experimental Methods Analysis Optimization Algorithms, 209--222. Springer, Berlin, Germany. doi:10.1007/978-3-642-02538-9_9 . Carlos M. Fonseca, Andreia P. Guerreiro, Manuel López-Ibá~nez, Luís Paquete (2011). “Computation Empirical Attainment Function.” R H C Takahashi,  others (eds.),  Evolutionary Multi-criterion Optimization, EMO 2011, volume 6576 Lecture Notes Computer Science, 106--120. Springer,  Heidelberg . doi:10.1007/978-3-642-19893-9_8 .","code":""},{"path":[]},{"path":"/reference/eaf-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computation and visualization of the empirical attainment function (EAF) for\nthe analysis of random sets in multi-criterion optimization. — eaf-package","text":"Maintainer: Manuel López-Ibáñez manuel.lopez-ibanez@manchester.ac.uk (ORCID) Authors: Marco Chiarandini Carlos Fonseca Luís Paquete Thomas Stützle contributors: Mickaël Binois [contributor]","code":""},{"path":"/reference/eaf-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computation and visualization of the empirical attainment function (EAF) for\nthe analysis of random sets in multi-criterion optimization. — eaf-package","text":"","code":"data(gcp2x2) tabucol<-subset(gcp2x2, alg!=\"TSinN1\") tabucol$alg<-tabucol$alg[drop=TRUE] eafplot(time+best~run,data=tabucol,subset=tabucol$inst==\"DSJC500.5\")   eafplot(time+best~run|inst,groups=alg,data=gcp2x2)  eafplot(time+best~run|inst,groups=alg,data=gcp2x2,   percentiles = c(0,50,100), cex = 1.4, lty = c(2,1,2),lwd = c(2,2,2),         col = c(\"black\",\"blue\",\"grey50\"))    extdata_path <- system.file(package=\"eaf\",\"extdata\") A1 <- read_datasets(file.path(extdata_path, \"wrots_l100w10_dat\")) A2 <- read_datasets(file.path(extdata_path, \"wrots_l10w100_dat\")) eafplot(A1, percentiles=c(50))  eafplot(list(A1=A1, A2=A2), percentiles=c(50))  eafdiffplot(A1, A2)  ## Save to a PDF file # dev.copy2pdf(file=\"eaf.pdf\", onefile=TRUE, width=5, height=4)"},{"path":"/reference/eafdiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute empirical attainment function differences — eafdiff","title":"Compute empirical attainment function differences — eafdiff","text":"Calculate differences empirical attainment functions two data sets.","code":""},{"path":"/reference/eafdiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute empirical attainment function differences — eafdiff","text":"","code":"eafdiff(x, y, intervals = NULL, maximise = c(FALSE, FALSE), rectangles = FALSE)"},{"path":"/reference/eafdiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute empirical attainment function differences — eafdiff","text":"x, y Data frames corresponding input data left right sides, respectively. data frame least three columns, third one set point. See also read_datasets(). intervals (integer(1))  absolute range differences \\([0, 1]\\) partitioned number intervals provided. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. rectangles TRUE, output form rectangles color.","code":""},{"path":"/reference/eafdiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute empirical attainment function differences — eafdiff","text":"rectangle=FALSE, data.frame containing points transition value EAF differences.  rectangle=TRUE, matrix first 4 columns give coordinates two corners rectangle last column. cases, last column gives difference terms sets x minus sets y attain point (.e., negative values differences favour y).","code":""},{"path":"/reference/eafdiff.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute empirical attainment function differences — eafdiff","text":"function calculates differences EAFs two data sets.","code":""},{"path":[]},{"path":"/reference/eafdiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute empirical attainment function differences — eafdiff","text":"","code":"A1 <- read_datasets(text='  3 2  2 3    2.5 1  1 2    1 2 ') A2 <- read_datasets(text='  4 2.5  3 3  2.5 3.5    3 3  2.5 3.5    2 1 ') d <- eafdiff(A1, A2) str(d) #>  num [1:9, 1:3] 1 2 2.5 2 2 3 2.5 3 4 2 ... print(d) #>       [,1] [,2] [,3] #>  [1,]  1.0  2.0    2 #>  [2,]  2.0  1.0   -1 #>  [3,]  2.5  1.0    0 #>  [4,]  2.0  2.0    1 #>  [5,]  2.0  3.0    2 #>  [6,]  3.0  2.0    2 #>  [7,]  2.5  3.5    0 #>  [8,]  3.0  3.0    0 #>  [9,]  4.0  2.5    1  d <- eafdiff(A1, A2, rectangles = TRUE) str(d) #>  num [1:9, 1:5] 2 1 2.5 2 2 2 3 3 4 1 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:5] \"xmin\" \"ymin\" \"xmax\" \"ymax\" ... print(d) #>       xmin ymin xmax ymax diff #>  [1,]  2.0  1.0  2.5  2.0   -1 #>  [2,]  1.0  2.0  2.0  Inf    2 #>  [3,]  2.5  1.0  Inf  2.0    0 #>  [4,]  2.0  2.0  3.0  3.0    1 #>  [5,]  2.0  3.5  2.5  Inf    2 #>  [6,]  2.0  3.0  3.0  3.5    2 #>  [7,]  3.0  2.5  4.0  3.0    2 #>  [8,]  3.0  2.0  Inf  2.5    2 #>  [9,]  4.0  2.5  Inf  3.0    1"},{"path":"/reference/eafdiffplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot empirical attainment function differences — eafdiffplot","title":"Plot empirical attainment function differences — eafdiffplot","text":"Plot differences empirical attainment functions (EAFs) two data sets two-panel plot, left side shows values left EAF minus right EAF right side shows differences direction.","code":""},{"path":"/reference/eafdiffplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot empirical attainment function differences — eafdiffplot","text":"","code":"eafdiffplot(   data.left,   data.right,   col = c(\"#FFFFFF\", \"#808080\", \"#000000\"),   intervals = 5,   percentiles = c(50),   full.eaf = FALSE,   type = \"area\",   legend.pos = if (full.eaf) \"bottomleft\" else \"topright\",   title.left = deparse(substitute(data.left)),   title.right = deparse(substitute(data.right)),   xlim = NULL,   ylim = NULL,   cex = par(\"cex\"),   cex.lab = par(\"cex.lab\"),   cex.axis = par(\"cex.axis\"),   maximise = c(FALSE, FALSE),   grand.lines = TRUE,   sci.notation = FALSE,   left.panel.last = NULL,   right.panel.last = NULL,   ... )"},{"path":"/reference/eafdiffplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot empirical attainment function differences — eafdiffplot","text":"data.left, data.right Data frames corresponding input data left right sides, respectively. data frame least three columns, third one set point. See also read_datasets(). col character vector three colors magnitude differences 0, 0.5, 1. Intermediate colors computed automatically given value intervals. Alternatively, function viridisLite::viridis() generates colormap given integer argument. intervals (integer(1)|character())  absolute range differences \\([0, 1]\\) partitioned number intervals provided. integer provided, labels interval  computed automatically. character vector provided, length taken number intervals. percentiles percentiles EAF side plotted attainment surfaces. NA plot . See eafplot(). full.eaf Whether plot EAF side instead differences EAFs. type Whether EAF differences plotted points (points) whether color areas least certain value (area). legend.pos position legend. See legend().  value \"none\" hides legend. title.left, title.right Title left right panels, respectively. xlim, ylim, cex, cex.lab, cex.axis Graphical parameters, see plot.default(). maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. grand.lines Whether plot grand-best grand-worst attainment surfaces. sci.notation Generate prettier labels left.panel.last, right.panel.last expression evaluated plotting taken place panel (left right). can useful adding points text either panel.  Note works lazy evaluation: passing argument plot methods may well work since may evaluated early. ... graphical parameters passed plot.default().","code":""},{"path":"/reference/eafdiffplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot empirical attainment function differences — eafdiffplot","text":"Returns representation EAF differences (invisibly).","code":""},{"path":"/reference/eafdiffplot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot empirical attainment function differences — eafdiffplot","text":"function calculates differences EAFs two data sets, plots left differences favour left data set, right differences favour right data set. default, also plots grand best worst attainment surfaces, , 0%- 100%-attainment surfaces data. two surfaces delimit area differences may exist. addition, also plots 50%-attainment surface data set. type = \"point\", points change value EAF difference plotted. means areas EAF differences stays constant, region appear white even value differences region large. explains \"white holes\" surrounded black points. type = \"area\", area EAF differences certain value plotted.  idea algorithm compute areas provided Carlos M. Fonseca.  implementation uses R polygons, PDF viewers may trouble rendering correctly (See https://cran.r-project.org/doc/FAQ/R-FAQ.html#---unwanted-borders). Plots () look correct printed. Large differences appear using type = \"point\" may seem disappear using type = \"area\". explanation points size independent axes range, therefore, plotted points may seem cover much larger area actual number points. hand, areas size plotted respect objective space, without extra borders. range area becomes smaller one-pixel, visible. consequence, zooming certain regions plots change apparent size points, whereas affects considerably apparent size areas.","code":""},{"path":[]},{"path":"/reference/eafdiffplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot empirical attainment function differences — eafdiffplot","text":"","code":"## NOTE: The plots in the website look squashed because of how pkgdown ## generates them. They should look fine when you generate them yourself. extdata_dir <- system.file(package=\"eaf\", \"extdata\")  A1 <- read_datasets(file.path(extdata_dir, \"ALG_1_dat.xz\")) A2 <- read_datasets(file.path(extdata_dir, \"ALG_2_dat.xz\")) # These take time eafdiffplot(A1, A2, full.eaf = TRUE)  if (requireNamespace(\"viridisLite\", quietly=TRUE)) {   viridis_r <- function(n) viridisLite::viridis(n, direction=-1)   eafdiffplot(A1, A2, type = \"area\", col = viridis_r) } else {   eafdiffplot(A1, A2, type = \"area\") }  A1 <- read_datasets(file.path(extdata_dir, \"wrots_l100w10_dat\")) A2 <- read_datasets(file.path(extdata_dir, \"wrots_l10w100_dat\")) eafdiffplot(A1, A2, type = \"point\", sci.notation = TRUE, cex.axis=0.6)   # A more complex example DIFF <- eafdiffplot(A1, A2, col = c(\"white\", \"blue\", \"red\"), intervals = 5,                     type = \"point\",                     title.left=expression(\"W-RoTS,\" ~ lambda==100 * \",\" ~ omega==10),                     title.right=expression(\"W-RoTS,\" ~ lambda==10 * \",\" ~ omega==100),                     right.panel.last={                       abline(a = 0, b = 1, col = \"red\", lty = \"dashed\")})  DIFF$right[,3] <- -DIFF$right[,3]  ## Save the values to a file. # write.table(rbind(DIFF$left,DIFF$right), #             file = \"wrots_l100w10_dat-wrots_l10w100_dat-diff.txt\", #             quote = FALSE, row.names = FALSE, col.names = FALSE)"},{"path":"/reference/eafplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the Empirical Attainment Function for two objectives — eafplot","title":"Plot the Empirical Attainment Function for two objectives — eafplot","text":"Computes plots Empirical Attainment Function, either attainment surfaces certain percentiles points.","code":""},{"path":"/reference/eafplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the Empirical Attainment Function for two objectives — eafplot","text":"","code":"eafplot(x, ...)  # S3 method for default eafplot(   x,   sets = NULL,   groups = NULL,   percentiles = c(0, 50, 100),   attsurfs = NULL,   xlab = NULL,   ylab = NULL,   xlim = NULL,   ylim = NULL,   log = \"\",   type = \"point\",   col = NULL,   lty = c(\"dashed\", \"solid\", \"solid\", \"solid\", \"dashed\"),   lwd = 1.75,   pch = NA,   cex.pch = par(\"cex\"),   las = par(\"las\"),   legend.pos = \"topright\",   legend.txt = NULL,   extra.points = NULL,   extra.legend = NULL,   extra.pch = 4:25,   extra.lwd = 0.5,   extra.lty = NA,   extra.col = \"black\",   maximise = c(FALSE, FALSE),   xaxis.side = \"below\",   yaxis.side = \"left\",   axes = TRUE,   sci.notation = FALSE,   ... )  # S3 method for formula eafplot(formula, data, groups = NULL, subset = NULL, ...)  # S3 method for list eafplot(x, ...)"},{"path":"/reference/eafplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the Empirical Attainment Function for two objectives — eafplot","text":"x Either matrix data values, data frame, list data frames exactly three columns. ... graphical parameters plot.default(). sets (numeric) Vector indicating set point belongs . groups may used plot profiles different algorithms plot. percentiles (numeric()) Vector indicating percentile plot. default plot median attainment curve. attsurfs TODO xlab, ylab, xlim, ylim, log, col, lty, lwd, pch, cex.pch, las Graphical parameters, see plot.default(). type (character(1)) string giving type plot desired.  following values possible, points area. legend.pos position legend, see legend().  value \"none\" hides legend. legend.txt character expression vector appear legend. NULL, appropriate labels generated. extra.points list matrices data.frames two-columns. element list defines set points, lines one columns NA. extra.legend character vector providing labels groups points. extra.pch, extra.lwd, extra.lty, extra.col Control graphical aspect points. See points() lines(). maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. xaxis.side side xaxis drawn. Valid values \"\" \"\". See axis(). yaxis.side side yaxis drawn. Valid values \"left\" \"right\". See axis(). axes logical value indicating whether axes drawn plot. sci.notation Generate prettier labels formula formula type: time + cost ~ run | instance draw time x-axis cost y-axis. instance present plot conditional instances. data Dataframe containing fields mentioned formula groups. subset (integer() | NULL) vector indicating rows data used. left default NULL data data frame used.","code":""},{"path":"/reference/eafplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the Empirical Attainment Function for two objectives — eafplot","text":"Return (invisibly) attainment surfaces computed.","code":""},{"path":"/reference/eafplot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot the Empirical Attainment Function for two objectives — eafplot","text":"function can used plot random sets points like obtained different runs biobjective stochastic optimization algorithms.  EAF curve represents boundary separating points known attainable (, dominated Pareto sense) least fraction (quantile) runs . median EAF represents curve fraction attainable points 50%.  single objective optimization function can used plot profile solution quality time collection runs stochastic optimizer.","code":""},{"path":"/reference/eafplot.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Plot the Empirical Attainment Function for two objectives — eafplot","text":"eafplot(default): Main function eafplot(formula): Formula interface eafplot(list): List interface lists data.frames matrices","code":""},{"path":[]},{"path":"/reference/eafplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the Empirical Attainment Function for two objectives — eafplot","text":"","code":"data(gcp2x2) tabucol <- subset(gcp2x2, alg != \"TSinN1\") tabucol$alg <- tabucol$alg[drop=TRUE] eafplot(time + best ~ run, data = tabucol, subset = tabucol$inst==\"DSJC500.5\")   # These take time eafplot(time + best ~ run | inst, groups=alg, data=gcp2x2)  eafplot(time + best ~ run | inst, groups=alg, data=gcp2x2,   percentiles=c(0,50,100), cex.axis = 0.8, lty = c(2,1,2), lwd = c(2,2,2),      col = c(\"black\",\"blue\",\"grey50\"))   extdata_path <- system.file(package = \"eaf\", \"extdata\") A1 <- read_datasets(file.path(extdata_path, \"ALG_1_dat.xz\")) A2 <- read_datasets(file.path(extdata_path, \"ALG_2_dat.xz\")) eafplot(A1, percentiles = 50, sci.notation = TRUE, cex.axis=0.6)  # The attainment surfaces are returned invisibly. attsurfs <- eafplot(list(A1 = A1, A2 = A2), percentiles = 50)  str(attsurfs) #> List of 2 #>  $ 50: num [1:1183, 1:2] 4.95e+09 4.95e+09 4.95e+09 4.95e+09 4.96e+09 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1183] \"1\" \"2\" \"3\" \"4\" ... #>   .. ..$ : chr [1:2] \"X1\" \"X2\" #>  $ 50: num [1:1422, 1:2] 5.16e+09 5.17e+09 5.18e+09 5.21e+09 5.21e+09 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1422] \"1184\" \"1185\" \"1186\" \"1187\" ... #>   .. ..$ : chr [1:2] \"X1\" \"X2\"  ## Save as a PDF file. # dev.copy2pdf(file = \"eaf.pdf\", onefile = TRUE, width = 5, height = 4)   ## Using extra.points # \\dontrun{ data(HybridGA) data(SPEA2relativeVanzyl) eafplot(SPEA2relativeVanzyl, percentiles = c(25, 50, 75),          xlab = expression(C[E]), ylab = \"Total switches\", xlim = c(320, 400),         extra.points = HybridGA$vanzyl, extra.legend = \"Hybrid GA\")   data(SPEA2relativeRichmond) eafplot (SPEA2relativeRichmond, percentiles = c(25, 50, 75),          xlab = expression(C[E]), ylab = \"Total switches\",          xlim = c(90, 140), ylim = c(0, 25),          extra.points = HybridGA$richmond, extra.lty = \"dashed\",          extra.legend = \"Hybrid GA\")   eafplot (SPEA2relativeRichmond, percentiles = c(25, 50, 75),          xlab = expression(C[E]), ylab = \"Total switches\",          xlim = c(90, 140), ylim = c(0, 25), type = \"area\",          extra.points = HybridGA$richmond, extra.lty = \"dashed\",          extra.legend = \"Hybrid GA\", legend.pos = \"bottomright\")   data(SPEA2minstoptimeRichmond) SPEA2minstoptimeRichmond[,2] <- SPEA2minstoptimeRichmond[,2] / 60 eafplot (SPEA2minstoptimeRichmond, xlab = expression(C[E]),          ylab = \"Minimum idle time (minutes)\", maximise = c(FALSE, TRUE),          las = 1, log = \"y\", main = \"SPEA2 (Richmond)\",          legend.pos = \"bottomright\")  # }"},{"path":"/reference/eafs.html","id":null,"dir":"Reference","previous_headings":"","what":"Exact computation of the EAF in 2D or 3D — eafs","title":"Exact computation of the EAF in 2D or 3D — eafs","text":"function computes EAF given set 2D 3D points vector set indicates set point belongs.","code":""},{"path":"/reference/eafs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exact computation of the EAF in 2D or 3D — eafs","text":"","code":"eafs(points, sets, groups = NULL, percentiles = NULL)"},{"path":"/reference/eafs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exact computation of the EAF in 2D or 3D — eafs","text":"points Either matrix data frame numerical values, row gives coordinates point. sets vector indicating set point belongs . groups Indicates EAF must computed separately data belonging different groups. percentiles (numeric()) Vector indicating percentiles computed. NULL computes .","code":""},{"path":"/reference/eafs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exact computation of the EAF in 2D or 3D — eafs","text":"data frame (data.frame) containing exact representation EAF. last column gives percentile corresponds point. groups NULL, additional column indicates group point belongs.","code":""},{"path":"/reference/eafs.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Exact computation of the EAF in 2D or 3D — eafs","text":"several examples data sets system.file(package=\"eaf\",\"extdata\"). current implementation supports two three dimensional points.","code":""},{"path":"/reference/eafs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Exact computation of the EAF in 2D or 3D — eafs","text":"Viviane Grunert da Fonseca, Carlos M. Fonseca, Andreia O. Hall (2001). “Inferential Performance Assessment Stochastic Optimisers Attainment Function.” Eckart Zitzler, Kalyanmoy Deb, Lothar Thiele, Carlos . Coello Coello, David Corne (eds.), Evolutionary Multi-criterion Optimization, EMO 2001, volume 1993 Lecture Notes Computer Science, 213--225. Springer, Heidelberg, Germany. doi:10.1007/3-540-44719-9_15 . Carlos M. Fonseca, Andreia P. Guerreiro, Manuel López-Ibá~nez, Luís Paquete (2011). “Computation Empirical Attainment Function.” R H C Takahashi,  others (eds.),  Evolutionary Multi-criterion Optimization, EMO 2011, volume 6576 Lecture Notes Computer Science, 106--120. Springer,  Heidelberg . doi:10.1007/978-3-642-19893-9_8 .","code":""},{"path":[]},{"path":"/reference/eafs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Exact computation of the EAF in 2D or 3D — eafs","text":"Manuel López-Ibáñez","code":""},{"path":"/reference/eafs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exact computation of the EAF in 2D or 3D — eafs","text":"","code":"extdata_path <- system.file(package=\"eaf\", \"extdata\")  x <- read_datasets(file.path(extdata_path, \"example1_dat\")) # Compute full EAF str(eafs(x[,1:2], x[,3])) #>  num [1:215, 1:3] 5128176 5134240 5142568 5144532 5155408 ...  # Compute only best, median and worst str(eafs(x[,1:2], x[,3], percentiles = c(0, 50, 100))) #>  num [1:50, 1:3] 5128176 5134240 5142568 5144532 5155408 ...  x <- read_datasets(file.path(extdata_path, \"spherical-250-10-3d.txt\")) y <- read_datasets(file.path(extdata_path, \"uniform-250-10-3d.txt\")) x <- rbind(data.frame(x, groups = \"spherical\"),            data.frame(y, groups = \"uniform\")) # Compute only median separately for each group z <- eafs(x[,1:3], sets = x[,4], groups = x[,5], percentiles = 50) str(z) #> 'data.frame':\t12650 obs. of  5 variables: #>  $ X1    : num  0.865 0.787 0.682 0.739 0.865 ... #>  $ X2    : num  0.966 0.966 0.997 0.966 0.926 ... #>  $ X3    : num  0.00264 0.00421 0.00483 0.00449 0.00421 ... #>  $ X4    : num  50 50 50 50 50 50 50 50 50 50 ... #>  $ groups: chr  \"spherical\" \"spherical\" \"spherical\" \"spherical\" ... # library(plotly) # plot_ly(z, x = ~X1, y = ~X2, z = ~X3, color = ~groups, #         colors = c('#BF382A', '#0C4B8E')) %>% add_markers()"},{"path":"/reference/epsilon.html","id":null,"dir":"Reference","previous_headings":"","what":"Epsilon metric — epsilon","title":"Epsilon metric — epsilon","text":"Computes epsilon metric, either additive multiplicative.","code":""},{"path":"/reference/epsilon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Epsilon metric — epsilon","text":"","code":"epsilon_additive(data, reference, maximise = FALSE)  epsilon_mult(data, reference, maximise = FALSE)"},{"path":"/reference/epsilon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Epsilon metric — epsilon","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (matrix | data.frame)  Reference set matrix data.frame numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"/reference/epsilon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Epsilon metric — epsilon","text":"single numerical value.","code":""},{"path":"/reference/epsilon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Epsilon metric — epsilon","text":"epsilon metric set \\(\\) respect reference set \\(R\\) defined $$epsilon(,R) = \\max_{r \\R} \\min_{\\} \\max_{1 \\leq \\leq n} epsilon(a_i, r_i)$$ \\(\\) \\(b\\) objective vectors , case minimization objective \\(\\), \\(epsilon(a_i,b_i)\\) computed \\(a_i/b_i\\) multiplicative variant (respectively, \\(a_i - b_i\\) additive variant), whereas case maximization objective \\(\\), \\(epsilon(a_i,b_i) = b_i/a_i\\) multiplicative variant (respectively, \\(b_i - a_i\\) additive variant). allows computing single value problems objectives maximized others minimized. Moreover, lower value corresponds better approximation set, independently type problem (minimization, maximization mixed). However, meaning value different objective type. example, imagine objective 1 minimized objective 2 maximized, multiplicative epsilon computed \\(epsilon(,R) = 3\\). means \\(\\) needs multiplied 1/3 \\(a_1\\) values 3 \\(a_2\\) values order weakly dominate \\(R\\). computation multiplicative version negative values make sense. Computation epsilon indicator requires \\(O(n \\cdot || \\cdot |R|)\\), \\(n\\) number objectives (dimension vectors).","code":""},{"path":"/reference/epsilon.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Epsilon metric — epsilon","text":"Eckart Zitzler, Lothar Thiele, Marco Laumanns, Carlos M. Fonseca, Viviane Grunert da Fonseca (2003). “Performance Assessment Multiobjective Optimizers: Analysis Review.” IEEE Transactions Evolutionary Computation, 7(2), 117--132.","code":""},{"path":"/reference/epsilon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Epsilon metric — epsilon","text":"Manuel López-Ibáñez","code":""},{"path":"/reference/epsilon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Epsilon metric — epsilon","text":"","code":"# Fig 6 from Zitzler et al. (2003). A1 <- matrix(c(9,2,8,4,7,5,5,6,4,7), ncol=2, byrow=TRUE) A2 <- matrix(c(8,4,7,5,5,6,4,7), ncol=2, byrow=TRUE) A3 <- matrix(c(10,4,9,5,8,6,7,7,6,8), ncol=2, byrow=TRUE)  plot(A1, xlab=expression(f[1]), ylab=expression(f[2]),      panel.first=grid(nx=NULL), pch=4, cex=1.5, xlim = c(0,10), ylim=c(0,8)) points(A2, pch=0, cex=1.5) points(A3, pch=1, cex=1.5) legend(\"bottomleft\", legend=c(\"A1\", \"A2\", \"A3\"), pch=c(4,0,1),        pt.bg=\"gray\", bg=\"white\", bty = \"n\", pt.cex=1.5, cex=1.2)  epsilon_mult(A1, A3) # A1 epsilon-dominates A3 => e = 9/10 < 1  #> [1] 0.9 epsilon_mult(A1, A2) # A1 weakly dominates A2 => e = 1 #> [1] 1 epsilon_mult(A2, A1) # A2 is epsilon-dominated by A1 => e = 2 > 1 #> [1] 2  # A more realistic example extdata_path <- system.file(package=\"eaf\",\"extdata\") path.A1 <- file.path(extdata_path, \"ALG_1_dat.xz\") path.A2 <- file.path(extdata_path, \"ALG_2_dat.xz\") A1 <- read_datasets(path.A1)[,1:2] A2 <- read_datasets(path.A2)[,1:2] ref <- filter_dominated(rbind(A1, A2)) epsilon_additive(A1, ref) #> [1] 199090640 epsilon_additive(A2, ref) #> [1] 132492066 # Multiplicative version of epsilon metric ref <- filter_dominated(rbind(A1, A2)) epsilon_mult(A1, ref) #> [1] 1.054015 epsilon_mult(A2, ref) #> [1] 1.023755"},{"path":"/reference/gcp2x2.html","id":null,"dir":"Reference","previous_headings":"","what":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"Two metaheuristic algorithms, TabuCol (Hertz et al., 1987) simulated annealing (Johnson et al. 1991) , find good approximation chromatic number two random graphs. data goal providing example use eafplot comparing algorithm performance respect time quality modelled two objectives trade .","code":""},{"path":"/reference/gcp2x2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"","code":"gcp2x2"},{"path":"/reference/gcp2x2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"data frame 3133 observations following 6 variables. alg factor levels SAKempeFI TSinN1 inst factor levels DSJC500.5 DSJC500.9. Instances taken DIMACS repository. run numeric vector indicating run observation belong. best numeric vector indicating best solution number colors found corresponding run time. time numeric vector indicating time since beginning run observation. rescaling applied. titer numeric vector indicating iteration number corresponding observations.","code":""},{"path":"/reference/gcp2x2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"Marco Chiarandini (2005). Stochastic Local Search Methods Highly Constrained Combinatorial Optimisation Problems. Ph.D. thesis, FB Informatik, TU Darmstadt, Germany.  (page 138)","code":""},{"path":"/reference/gcp2x2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"algorithm run 10 times per graph registering time iteration number new best solution found. time limit corresponding 500*10^5 total iterations TabuCol imposed. time normalized scale 0 1 make instance independent.","code":""},{"path":"/reference/gcp2x2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":". Hertz D. de Werra. Using Tabu Search Techniques Graph Coloring. Computing, 1987, 39(4), 345-351. David S. Johnson, Cecilia R. Aragon, Lyle . McGeoch, Catherine Schevon (1991). “Optimization Simulated Annealing: Experimental Evaluation: Part II, Graph Coloring Number Partitioning.” Operations Research, 39(3), 378--406.","code":""},{"path":"/reference/gcp2x2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"","code":"data(gcp2x2)"},{"path":"/reference/hv_contributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Hypervolume contribution of a set of points — hv_contributions","title":"Hypervolume contribution of a set of points — hv_contributions","text":"Computes hypervolume contribution point given set points respect given reference point assuming minimization objectives.  Dominated points zero contribution. Duplicated points zero contribution even dominated, removing one change hypervolume dominated remaining set.","code":""},{"path":"/reference/hv_contributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hypervolume contribution of a set of points — hv_contributions","text":"","code":"hv_contributions(data, reference, maximise = FALSE)"},{"path":"/reference/hv_contributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hypervolume contribution of a set of points — hv_contributions","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (numeric())  Reference point vector numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"/reference/hv_contributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hypervolume contribution of a set of points — hv_contributions","text":"(numeric) numerical vector","code":""},{"path":"/reference/hv_contributions.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hypervolume contribution of a set of points — hv_contributions","text":"Carlos M. Fonseca, Luís Paquete, Manuel López-Ibáñez (2006). “improved dimension-sweep algorithm hypervolume indicator.” Proceedings 2006 Congress Evolutionary Computation (CEC 2006), 1157--1163. IEEE Press, Piscataway, NJ. doi:10.1109/CEC.2006.1688440 . Nicola Beume, Carlos M. Fonseca, Manuel López-Ibáñez, Luís Paquete, Jan Vahrenhold (2009). “complexity computing hypervolume indicator.” IEEE Transactions Evolutionary Computation, 13(5), 1075--1082. doi:10.1109/TEVC.2009.2015575 .","code":""},{"path":[]},{"path":"/reference/hv_contributions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hypervolume contribution of a set of points — hv_contributions","text":"Manuel López-Ibáñez","code":""},{"path":"/reference/hv_contributions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hypervolume contribution of a set of points — hv_contributions","text":"","code":"data(SPEA2minstoptimeRichmond) # The second objective must be maximized # We calculate the hypervolume contribution of each point of the union of all sets. hv_contributions(SPEA2minstoptimeRichmond[, 1:2], reference = c(250, 0),             maximise = c(FALSE, TRUE)) #>   [1]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>   [8]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [15]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [22]     0.000     4.380     0.000     0.000     0.000     0.000     0.000 #>  [29]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [36]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [43]     0.000     0.000     0.000     0.000     0.000     0.000  6397.052 #>  [50]  1945.800  3386.197     0.000     0.000     0.000     0.000     0.000 #>  [57]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [64]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [71]    26.255     0.000     0.000     0.000     0.000     0.000     0.000 #>  [78]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [85]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [92]     0.000    15.840     0.000     0.000     0.066     0.000     0.000 #>  [99]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [106]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [113]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [120]     0.000  3069.000   779.240     0.000     0.000     0.000     0.000 #> [127]     0.000     0.000     0.000     0.000     0.000 12428.431     0.000 #> [134]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [141]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [148]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [155]     0.000     0.000     0.000     0.000     0.000  2294.064     0.000 #> [162]     0.000     0.000     0.000     0.000     0.000  # Duplicated points show zero contribution above, even if not # dominated. However, filter_dominated removes all duplicates except # one. Hence, there are more points below with nonzero contribution. hv_contributions(filter_dominated(SPEA2minstoptimeRichmond[, 1:2], maximise = c(FALSE, TRUE)),                  reference = c(250, 0), maximise = c(FALSE, TRUE)) #>  [1]      8.197  89283.920   7959.940   1945.800   8147.132     26.255 #>  [7] 255278.978   3698.640   2242.660      5.971   3069.000    779.240 #> [13]  41994.755   2294.064     73.054 193143.324"},{"path":"/reference/hypervolume.html","id":null,"dir":"Reference","previous_headings":"","what":"Hypervolume metric — hypervolume","title":"Hypervolume metric — hypervolume","text":"Computes hypervolume metric respect given reference point assuming minimization objectives.","code":""},{"path":"/reference/hypervolume.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hypervolume metric — hypervolume","text":"","code":"hypervolume(data, reference, maximise = FALSE)"},{"path":"/reference/hypervolume.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hypervolume metric — hypervolume","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (numeric())  Reference point vector numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"/reference/hypervolume.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hypervolume metric — hypervolume","text":"single numerical value.","code":""},{"path":"/reference/hypervolume.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hypervolume metric — hypervolume","text":"algorithm \\(O(n^{d-2} \\log n)\\) time linear space complexity worst-case, experimental results show pruning techniques used may reduce time complexity even .","code":""},{"path":"/reference/hypervolume.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hypervolume metric — hypervolume","text":"Carlos M. Fonseca, Luís Paquete, Manuel López-Ibáñez (2006). “improved dimension-sweep algorithm hypervolume indicator.” Proceedings 2006 Congress Evolutionary Computation (CEC 2006), 1157--1163. IEEE Press, Piscataway, NJ. doi:10.1109/CEC.2006.1688440 . Nicola Beume, Carlos M. Fonseca, Manuel López-Ibáñez, Luís Paquete, Jan Vahrenhold (2009). “complexity computing hypervolume indicator.” IEEE Transactions Evolutionary Computation, 13(5), 1075--1082. doi:10.1109/TEVC.2009.2015575 .","code":""},{"path":"/reference/hypervolume.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hypervolume metric — hypervolume","text":"Manuel López-Ibáñez","code":""},{"path":"/reference/hypervolume.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hypervolume metric — hypervolume","text":"","code":"data(SPEA2minstoptimeRichmond) # The second objective must be maximized # We calculate the hypervolume of the union of all sets. hypervolume(SPEA2minstoptimeRichmond[, 1:2], reference = c(250, 0),             maximise = c(FALSE, TRUE)) #> [1] 7911376"},{"path":"/reference/igd.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"Functions compute inverted generational distance (IGD IGD+) averaged Hausdorff distance nondominated sets points.","code":""},{"path":"/reference/igd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"","code":"igd(data, reference, maximise = FALSE)  igd_plus(data, reference, maximise = FALSE)  avg_hausdorff_dist(data, reference, maximise = FALSE, p = 1L)"},{"path":"/reference/igd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (matrix | data.frame)  Reference set matrix data.frame numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. p (integer(1)) Hausdorff distance parameter (default: 1L).","code":""},{"path":"/reference/igd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"(numeric(1)) single numerical value.","code":""},{"path":"/reference/igd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"generational distance (GD) set \\(\\) defined distance point \\(\\\\) closest point \\(r\\) reference set \\(R\\), averaged size \\(\\). Formally, $$GD_p(,R) = \\left(\\frac{1}{||}\\sum_{\\}\\min_{r\\R} d(,r)^p\\right)^{\\frac{1}{p}} $$ distance implementation Euclidean distance: $$d(,r) = \\sqrt{\\sum_{k=1}^M (a_k - r_k)^2} $$ inverted generational distance (IGD) calculated \\(IGD_p(,R) = GD_p(R,)\\). modified inverted generational distanced (IGD+) proposed Ishibuchi et al. (2015)  ensure IGD+ weakly Pareto compliant, similarly epsilon_additive() epsilon_mult(). modifies distance measure : $$d^+(r,) = \\sqrt{\\sum_{k=1}^M (\\max\\{r_k - a_k, 0\\})^2}$$ average Hausdorff distance (\\(\\Delta_p\\)) proposed Schütze et al. (2012)  calculated : $$\\Delta_p(,R) = \\max\\{ IGD_p(,R), IGD_p(R,) \\}$$ IGDX (Zhou et al. 2009)  application IGD decision vectors instead objective vectors measure closeness diversity decision space. One can use functions igd() igd_plus() (recommended) directly, just passing decision vectors data. different formulations GD IGD metrics literature differ value \\(p\\), distance metric used whether term \\(||^{-1}\\) inside () outside exponent \\(1/p\\).  GD first proposed Van Veldhuizen Lamont (1998)  \\(p=2\\) term \\(||^{-1}\\) outside exponent. IGD seems mentioned first Coello Coello Reyes-Sierra (2004) , however, people also used name D-metric concept \\(p=1\\) later papers often used IGD/GD \\(p=1\\). Schütze et al. (2012)  proposed place term \\(||^{-1}\\) inside exponent, formulation shown .  significant effect GD less IGD given constant reference set. IGD+ also follows formulation.  refer Ishibuchi et al. (2015)  Bezerra et al. (2017)  detailed historical perspective comparison various variants. Following Ishibuchi et al. (2015) , always use \\(p=1\\) implementation IGD IGD+ (1) setting used recent works; (2) makes irrelevant whether term \\(||^{-1}\\) inside outside exponent \\(1/p\\); (3) meaning IGD becomes average Euclidean distance reference point nearest objective vector). also slightly faster compute. GD never used directly compare quality approximations Pareto front, often contradicts Pareto optimality (weakly Pareto-compliant). recommend IGD+ instead IGD, since latter contradicts Pareto optimality cases (see examples ) whereas IGD+ weakly Pareto-compliant, implement IGD still popular due historical reasons. average Hausdorff distance (\\(\\Delta_p(,R)\\)) also weakly Pareto-compliant, shown examples .","code":""},{"path":"/reference/igd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"Leonardo C. T. Bezerra, Manuel López-Ibáñez, Thomas Stützle (2017). “Empirical Assessment Properties Inverted Generational Distance Indicators Multi- Many-objective Optimization.” Heike Trautmann, Günter Rudolph, Kathrin Klamroth, Oliver Schütze, Margaret M. Wiecek, Yaochu Jin, Christian Grimme (eds.), Evolutionary Multi-criterion Optimization, EMO 2017,  Lecture Notes Computer Science, 31--45. Springer International Publishing, Cham, Switzerland. doi:10.1007/978-3-319-54157-0_3 . Carlos . Coello Coello, Margarita Reyes-Sierra (2004). “Study Parallelization Coevolutionary Multi-objective Evolutionary Algorithm.” Raúl Monroy, Gustavo Arroyo-Figueroa, Luis Enrique Sucar, Humberto Sossa (eds.), Proceedings MICAI, volume 2972 Lecture Notes Artificial Intelligence, 688--697. Springer, Heidelberg, Germany. Hisao Ishibuchi, Hiroyuki Masuda, Yuki Tanigaki, Yusuke Nojima (2015). “Modified Distance Calculation Generational Distance Inverted Generational Distance.” António Gaspar-Cunha, Carlos Henggeler Antunes, Carlos . Coello Coello (eds.), Evolutionary Multi-criterion Optimization, EMO 2015 Part , volume 9018 Lecture Notes Computer Science, 110--125. Springer, Heidelberg, Germany. Oliver Schütze, X Esquivel, Lara, Carlos . Coello Coello (2012). “Using Averaged Hausdorff Distance Performance Measure Evolutionary Multiobjective Optimization.” IEEE Transactions Evolutionary Computation, 16(4), 504--522. David . Van Veldhuizen, Gary B. Lamont (1998). “Evolutionary Computation Convergence Pareto Front.” John R. Koza (ed.), Late Breaking Papers Genetic Programming 1998 Conference, 221--228. Zhou, Qingfu Zhang, Yaochu Jin (2009). “Approximating set Pareto-optimal solutions decision objective spaces estimation distribution algorithm.” IEEE Transactions Evolutionary Computation, 13(5), 1167--1189. doi:10.1109/TEVC.2009.2021467 .","code":""},{"path":"/reference/igd.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"Manuel López-Ibáñez","code":""},{"path":"/reference/igd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"","code":"# Example 4 from Ishibuchi et al. (2015) ref <- matrix(c(10,0,6,1,2,2,1,6,0,10), ncol=2, byrow=TRUE) A <- matrix(c(4,2,3,3,2,4), ncol=2, byrow=TRUE) B <- matrix(c(8,2,4,4,2,8), ncol=2, byrow=TRUE) plot(ref, xlab=expression(f[1]), ylab=expression(f[2]),      panel.first=grid(nx=NULL), pch=23, bg=\"gray\", cex=1.5) points(A, pch=1, cex=1.5) points(B, pch=19, cex=1.5) legend(\"topright\", legend=c(\"Reference\", \"A\", \"B\"), pch=c(23,1,19),        pt.bg=\"gray\", bg=\"white\", bty = \"n\", pt.cex=1.5, cex=1.2)  cat(\"A is better than B in terms of Pareto optimality,\\n however, IGD(A)=\",     igd(A, ref), \"> IGD(B)=\", igd(B, ref),     \"and AvgHausdorff(A)=\", avg_hausdorff_dist(A, ref),     \"> AvgHausdorff(A)=\", avg_hausdorff_dist(B, ref),     \", which both contradict Pareto optimality.\\nBy contrast, IGD+(A)=\",     igd_plus(A, ref), \"< IGD+(B)=\", igd_plus(B, ref), \", which is correct.\\n\") #> A is better than B in terms of Pareto optimality, #>  however, IGD(A)= 3.707092 > IGD(B)= 2.591483 and AvgHausdorff(A)= 3.707092 > AvgHausdorff(A)= 2.591483 , which both contradict Pareto optimality. #> By contrast, IGD+(A)= 1.482843 < IGD+(B)= 2.260113 , which is correct.  # A less trivial example. extdata_path <- system.file(package=\"eaf\",\"extdata\") path.A1 <- file.path(extdata_path, \"ALG_1_dat.xz\") path.A2 <- file.path(extdata_path, \"ALG_2_dat.xz\") A1 <- read_datasets(path.A1)[,1:2] A2 <- read_datasets(path.A2)[,1:2] ref <- filter_dominated(rbind(A1, A2)) igd(A1, ref) #> [1] 91888189 igd(A2, ref) #> [1] 11351992  # IGD+ (Pareto compliant) igd_plus(A1, ref) #> [1] 82695357 igd_plus(A2, ref) #> [1] 10698269  # Average Haussdorff distance avg_hausdorff_dist(A1, ref) #> [1] 268547627 avg_hausdorff_dist(A2, ref) #> [1] 352613092"},{"path":"/reference/largest_eafdiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify largest EAF differences — largest_eafdiff","title":"Identify largest EAF differences — largest_eafdiff","text":"Given list datasets, return indexes pair largest EAF differences according method proposed Diaz López-Ibáñez (2021) .","code":""},{"path":"/reference/largest_eafdiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify largest EAF differences — largest_eafdiff","text":"","code":"largest_eafdiff(data, maximise = FALSE, intervals = 5, reference, ideal = NULL)"},{"path":"/reference/largest_eafdiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify largest EAF differences — largest_eafdiff","text":"data (list(1)) list matrices least 3 columns maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. intervals (integer(1))  absolute range differences \\([0, 1]\\) partitioned number intervals provided. reference (numeric())  Reference point vector numerical values. ideal (numeric())  Ideal point vector numerical values. NULL, calculated minimum (resp. maximum maximising objective) objective data.","code":""},{"path":"/reference/largest_eafdiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify largest EAF differences — largest_eafdiff","text":"(list()) list two components pair value.","code":""},{"path":"/reference/largest_eafdiff.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Identify largest EAF differences — largest_eafdiff","text":"Juan Esteban Diaz, Manuel López-Ibáñez (2021). “Incorporating Decision-Maker's Preferences Automatic Configuration Bi-Objective Optimisation Algorithms.” European Journal Operational Research, 289(3), 1209--1222. doi:10.1016/j.ejor.2020.07.059 .","code":""},{"path":"/reference/largest_eafdiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify largest EAF differences — largest_eafdiff","text":"","code":"# FIXME: This example is too large, we need a smaller one. files <- c(\"wrots_l100w10_dat\",\"wrots_l10w100_dat\") data <- lapply(files, function(x)                read_datasets(file.path(system.file(package=\"eaf\"),                              \"extdata\", x))) nadir <- apply(do.call(rbind, data)[,1:2], 2, max) x <- largest_eafdiff(data, reference = nadir) str(x) #> List of 2 #>  $ pair : int [1:2] 1 2 #>  $ value: num 6.6e+09"},{"path":"/reference/nondominated.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Identify nondominated points is_nondominated remove dominated ones filter_dominated. pareto_rank() ranks points according Pareto-optimality, also called nondominated sorting (Deb et al. 2002) .","code":""},{"path":"/reference/nondominated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"","code":"is_nondominated(data, maximise = FALSE, keep_weakly = FALSE)  filter_dominated(data, maximise = FALSE, keep_weakly = FALSE)  pareto_rank(data, maximise = FALSE)"},{"path":"/reference/nondominated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. keep_weakly FALSE, return FALSE duplicates nondominated points.","code":""},{"path":"/reference/nondominated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"is_nondominated returns logical vector length number rows data, TRUE means point dominated point. filter_dominated returns matrix data.frame mutually nondominated points. pareto_rank() returns integer vector length number rows data, value gives rank point.","code":""},{"path":"/reference/nondominated.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"pareto_rank() meant used like rank(), assigns ranks according Pareto dominance. Duplicated points kept front. ncol(data) == 2, code uses \\(O(n   \\log n)\\) algorithm Jensen (2003) .","code":""},{"path":"/reference/nondominated.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Kalyanmoy Deb, Pratap, S Agarwal, T Meyarivan (2002). “fast elitist multi-objective genetic algorithm: NSGA-II.” IEEE Transactions Evolutionary Computation, 6(2), 182--197. doi:10.1109/4235.996017 . M T Jensen (2003). “Reducing run-time complexity multiobjective EAs: NSGA-II algorithms.” IEEE Transactions Evolutionary Computation, 7(5), 503--515.","code":""},{"path":"/reference/nondominated.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Manuel López-Ibáñez","code":""},{"path":"/reference/nondominated.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"","code":"path_A1 <- file.path(system.file(package=\"eaf\"),\"extdata\",\"ALG_1_dat.xz\") set <- read_datasets(path_A1)[,1:2]  is_nondom <- is_nondominated(set) cat(\"There are \", sum(is_nondom), \" nondominated points\\n\") #> There are  583  nondominated points  plot(set, col = \"blue\", type = \"p\", pch = 20) ndset <- filter_dominated(set) points(ndset[order(ndset[,1]),], col = \"red\", pch = 21)   ranks <- pareto_rank(set) colors <- colorRampPalette(c(\"red\",\"yellow\",\"springgreen\",\"royalblue\"))(max(ranks)) plot(set, col = colors[ranks], type = \"p\", pch = 20)"},{"path":"/reference/normalise.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalise points — normalise","title":"Normalise points — normalise","text":"Normalise points per coordinate range, e.g., c(1,2), minimum value correspond 1 maximum 2. bounds given, used normalisation.","code":""},{"path":"/reference/normalise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalise points — normalise","text":"","code":"normalise(data, to_range = c(1, 2), lower = NA, upper = NA, maximise = FALSE)"},{"path":"/reference/normalise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalise points — normalise","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. to_range Normalise values range. objective maximised, normalised c(to_range[1], to_range[0]) instead. lower, upper Bounds values. NA, maximum minimum values coordinate used. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"/reference/normalise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalise points — normalise","text":"numerical matrix","code":""},{"path":"/reference/normalise.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Normalise points — normalise","text":"Manuel López-Ibáñez","code":""},{"path":"/reference/normalise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalise points — normalise","text":"","code":"data(SPEA2minstoptimeRichmond) # The second objective must be maximized head(SPEA2minstoptimeRichmond[, 1:2]) #>        V1    V2 #> 1 105.832   357 #> 2 108.187   911 #> 3 108.519  3960 #> 4 108.641  7560 #> 5 108.896 16532 #> 6 112.556 19957  head(normalise(SPEA2minstoptimeRichmond[, 1:2], maximise = c(FALSE, TRUE))) #>            V1       V2 #> [1,] 1.044174 2.000000 #> [2,] 1.059891 1.993561 #> [3,] 1.062107 1.958126 #> [4,] 1.062921 1.916286 #> [5,] 1.064623 1.812013 #> [6,] 1.089049 1.772207  head(normalise(SPEA2minstoptimeRichmond[, 1:2], to_range = c(0,1), maximise = c(FALSE, TRUE))) #>              V1        V2 #> [1,] 0.04417408 1.0000000 #> [2,] 0.05989095 0.9935614 #> [3,] 0.06210666 0.9581256 #> [4,] 0.06292087 0.9162860 #> [5,] 0.06462270 0.8120126 #> [6,] 0.08904891 0.7722069"},{"path":"/reference/pdf_crop.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove whitespace margins from a PDF file (and maybe embed fonts) — pdf_crop","title":"Remove whitespace margins from a PDF file (and maybe embed fonts) — pdf_crop","text":"Remove whitespace margins using https://ctan.org/pkg/pdfcrop optionally embed fonts using grDevices::embedFonts(). may install pdfcrop using TinyTeX (https://cran.r-project.org/package=tinytex) tinytex::tlmgr_install('pdfcrop').","code":""},{"path":"/reference/pdf_crop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove whitespace margins from a PDF file (and maybe embed fonts) — pdf_crop","text":"","code":"pdf_crop(   filename,   mustWork = FALSE,   pdfcrop = Sys.which(\"pdfcrop\"),   embed_fonts = FALSE )"},{"path":"/reference/pdf_crop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove whitespace margins from a PDF file (and maybe embed fonts) — pdf_crop","text":"filename Filename PDF file crop. file overwritten. mustWork TRUE, give error file cropped. pdfcrop Path pdfcrop utility. embed_fonts (logical(1)) TRUE, use grDevices::embedFonts() embed fonts.","code":""},{"path":"/reference/pdf_crop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove whitespace margins from a PDF file (and maybe embed fonts) — pdf_crop","text":"Nothing","code":""},{"path":"/reference/pdf_crop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove whitespace margins from a PDF file (and maybe embed fonts) — pdf_crop","text":"may also wish consider extrafont::embed_fonts() (https://cran.r-project.org/package=extrafont).   alternative, saving PDF grDevices::cairo_pdf() already embed fonts.","code":"library(extrafont) # If you need to specify the path to Ghostscript (probably not needed in Linux) Sys.setenv(R_GSCMD = \"C:/Program Files/gs/gs9.56.1/bin/gswin64c.exe\") embed_fonts(\"original.pdf\", outfile = \"new.pdf\")"},{"path":[]},{"path":"/reference/pdf_crop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove whitespace margins from a PDF file (and maybe embed fonts) — pdf_crop","text":"","code":"# \\dontrun{ extdata_path <- system.file(package = \"eaf\", \"extdata\") A1 <- read_datasets(file.path(extdata_path, \"wrots_l100w10_dat\")) A2 <- read_datasets(file.path(extdata_path, \"wrots_l10w100_dat\")) pdf(file = \"eaf.pdf\", onefile = TRUE, width = 5, height = 4) eafplot(list(A1 = A1, A2 = A2), percentiles = 50, sci.notation=TRUE) dev.off() #> agg_png  #>       2  pdf_crop(\"eaf.pdf\") #> Warning: pdfcrop not found, not cropping # }"},{"path":"/reference/read_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Read several data sets — read_datasets","title":"Read several data sets — read_datasets","text":"Reads text file table format creates matrix . file may contain several sets, separated empty lines. Lines starting '#' considered comments treated empty lines. function adds additional column set indicate set row belongs.","code":""},{"path":"/reference/read_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read several data sets — read_datasets","text":"","code":"read_datasets(file, col_names, text)  read.data.sets(file, col.names)"},{"path":"/reference/read_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read several data sets — read_datasets","text":"file (character())  Filename contains data.  row table appears one line file.  contain absolute path, file name relative current working directory, getwd().  Tilde-expansion performed supported.  Files compressed xz supported. col_names, col.names Vector optional names variables.  default use \"V\" followed column number. text (character())  file supplied , data read value text via text connection. Notice literal string can used include (small) data sets within R code.","code":""},{"path":"/reference/read_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read several data sets — read_datasets","text":"(matrix()) containing representation data file. extra column set added indicate set row belongs.","code":""},{"path":"/reference/read_datasets.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Read several data sets — read_datasets","text":"several examples data sets system.file(package=\"eaf\",\"extdata\"). read.data.sets() deprecated alias. removed next major release.","code":""},{"path":"/reference/read_datasets.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Read several data sets — read_datasets","text":"known limitation input file must use newline characters native host system, otherwise , possibly silently, misinterpreted. GNU/Linux program dos2unix may used fix newline characters.","code":""},{"path":[]},{"path":"/reference/read_datasets.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read several data sets — read_datasets","text":"Manuel López-Ibáñez","code":""},{"path":"/reference/read_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read several data sets — read_datasets","text":"","code":"extdata_path <- system.file(package=\"eaf\",\"extdata\") A1 <- read_datasets(file.path(extdata_path,\"ALG_1_dat.xz\")) str(A1) #>  num [1:23260, 1:3] 1.23e+10 1.11e+10 1.18e+10 1.13e+10 9.80e+09 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:3] \"V1\" \"V2\" \"set\"  read_datasets(text=\"1 2\\n3 4\\n\\n5 6\\n7 8\\n\", col_names=c(\"obj1\", \"obj2\")) #>      obj1 obj2 set #> [1,]    1    2   1 #> [2,]    3    4   1 #> [3,]    5    6   2 #> [4,]    7    8   2"},{"path":"/reference/whv_hype.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"Return estimation hypervolume space dominated input data following procedure described Auger et al. (2009) . weight distribution describing user preferences may specified.","code":""},{"path":"/reference/whv_hype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"","code":"whv_hype(   data,   reference,   ideal,   maximise = FALSE,   dist = list(type = \"uniform\"),   nsamples = 100000L )"},{"path":"/reference/whv_hype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (numeric())  Reference point vector numerical values. ideal (numeric())  Ideal point vector numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. dist (list()) weight distribution. See Details. nsamples (integer(1)) number samples Monte-Carlo sampling.","code":""},{"path":"/reference/whv_hype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"single numerical value.","code":""},{"path":"/reference/whv_hype.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"current implementation supports 2 objectives. weight distribution  (Auger et al. 2009)  can provided via dist argument. ones currently supported : type=\"uniform\" corresponds default hypervolume (unweighted). type=\"point\" describes goal objective space, mu gives coordinates goal. resulting weight distribution multivariate normal distribution centred goal. type=\"exponential\" describes exponential distribution rate parameter 1/mu, .e., \\(\\lambda = \\frac{1}{\\mu}\\).","code":""},{"path":"/reference/whv_hype.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"Anne Auger, Johannes Bader, Dimo Brockhoff, Eckart Zitzler (2009). “Articulating User Preferences Many-Objective Problems Sampling Weighted Hypervolume.” Franz Rothlauf (ed.), Proceedings Genetic Evolutionary Computation Conference, GECCO 2009, 555--562. ACM Press, New York, NY.","code":""},{"path":[]},{"path":"/reference/whv_hype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"","code":"whv_hype (matrix(2, ncol=2), reference = 4, ideal = 1) #> [1] 3.97845  whv_hype (matrix(c(3,1), ncol=2), reference = 4, ideal = 1) #> [1] 2.99169  whv_hype (matrix(2, ncol=2), reference = 4, ideal = 1,           dist = list(type=\"exponential\", mu=0.2)) #> [1] 1.14156  whv_hype (matrix(c(3,1), ncol=2), reference = 4, ideal = 1,           dist = list(type=\"exponential\", mu=0.2)) #> [1] 1.67103  whv_hype (matrix(2, ncol=2), reference = 4, ideal = 1,           dist = list(type=\"point\", mu=c(1,1))) #> [1] 0.80676  whv_hype (matrix(c(3,1), ncol=2), reference = 4, ideal = 1,           dist = list(type=\"point\", mu=c(1,1))) #> [1] 0.0378"},{"path":"/reference/whv_rect.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"Calculates hypervolume weighted set rectangles (zero weight outside rectangles). function total_whv_rect() calculates total weighted hypervolume hypervolume() + scalefactor * abs(prod(reference - ideal)) * whv_rect(). details computation given Diaz López-Ibáñez (2021) .","code":""},{"path":"/reference/whv_rect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"","code":"whv_rect(data, rectangles, reference, maximise = FALSE)  total_whv_rect(   data,   rectangles,   reference,   maximise = FALSE,   ideal = NULL,   scalefactor = 0.1 )"},{"path":"/reference/whv_rect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. rectangles (matrix()) Weighted rectangles bias computation hypervolume. Maybe generated eafdiff() rectangles=TRUE choose_eafdiff(). reference (numeric())  Reference point vector numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. ideal (numeric())  Ideal point vector numerical values. NULL, calculated minimum (resp. maximum maximising objective) objective data. scalefactor (numeric(1)) real value within \\((0,1]\\) scales overall weight differences. parameter psi (\\(\\psi\\)) Diaz López-Ibáñez (2021) .","code":""},{"path":"/reference/whv_rect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"single numerical value.","code":""},{"path":"/reference/whv_rect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"TODO","code":""},{"path":"/reference/whv_rect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"Juan Esteban Diaz, Manuel López-Ibáñez (2021). “Incorporating Decision-Maker's Preferences Automatic Configuration Bi-Objective Optimisation Algorithms.” European Journal Operational Research, 289(3), 1209--1222. doi:10.1016/j.ejor.2020.07.059 .","code":""},{"path":[]},{"path":"/reference/whv_rect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"","code":"rectangles <- as.matrix(read.table(header=FALSE, text='  1.0  3.0  2.0  Inf    1  2.0  3.5  2.5  Inf    2  2.0  3.0  3.0  3.5    3 ')) whv_rect (matrix(2, ncol=2), rectangles, reference = 6) #> [1] 4 whv_rect (matrix(c(2, 1), ncol=2), rectangles, reference = 6) #> [1] 4 whv_rect (matrix(c(1, 2), ncol=2), rectangles, reference = 6) #> [1] 7  total_whv_rect (matrix(2, ncol=2), rectangles, reference = 6, ideal = c(1,1)) #> [1] 26 total_whv_rect (matrix(c(2, 1), ncol=2), rectangles, reference = 6, ideal = c(1,1)) #> [1] 30 total_whv_rect (matrix(c(1, 2), ncol=2), rectangles, reference = 6, ideal = c(1,1)) #> [1] 37.5"},{"path":"/reference/write_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Write data sets — write_datasets","title":"Write data sets — write_datasets","text":"Write data sets file format read_datasets().","code":""},{"path":"/reference/write_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write data sets — write_datasets","text":"","code":"write_datasets(x, file = \"\")"},{"path":"/reference/write_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write data sets — write_datasets","text":"x data set write. last column must set number. file either character string naming file connection open writing. ‘\"\"’ indicates output console.","code":""},{"path":[]},{"path":"/reference/write_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write data sets — write_datasets","text":"","code":"x <- read_datasets(text=\"1 2\\n3 4\\n\\n5 6\\n7 8\\n\", col_names=c(\"obj1\", \"obj2\")) write_datasets(x) #> # obj1\tobj2  #> 1 2 #> 3 4 #>  #> 5 6 #> 7 8"},{"path":"/news/index.html","id":"eaf-25","dir":"Changelog","previous_headings":"","what":"eaf 2.5","title":"eaf 2.5","text":"Silence warnings GCC 12.","code":""},{"path":"/news/index.html","id":"eaf-24","dir":"Changelog","previous_headings":"","what":"eaf 2.4","title":"eaf 2.4","text":"CRAN release: 2023-01-12 installation find Gnu Scientific Library, gives hints install various operating systems. pdf_crop() can optionally embed fonts. Fix calculation ideal largest_eafdiff(). Fix configure script use compiler flags R.","code":""},{"path":"/news/index.html","id":"eaf-23","dir":"Changelog","previous_headings":"","what":"eaf 2.3","title":"eaf 2.3","text":"CRAN release: 2021-12-21 eafplot() now returns attainment surfaces computed invisibly. New functions pdf_crop(), write_datasets(), attsurf2df(). Fix bug made polygons extend beyond boundaries affecting eafdiff() eafdiffplot().","code":""},{"path":"/news/index.html","id":"eaf-22","dir":"Changelog","previous_headings":"","what":"eaf 2.2","title":"eaf 2.2","text":"CRAN release: 2021-10-06 col argument eafdiffplot() may colormap function.","code":""},{"path":"/news/index.html","id":"eaf-21","dir":"Changelog","previous_headings":"","what":"eaf 2.1","title":"eaf 2.1","text":"CRAN release: 2021-05-07 Improve documentation igd(). Fix errors single-point attainment surfaces. Fix bug eafplot.list().","code":""},{"path":"/news/index.html","id":"eaf-20","dir":"Changelog","previous_headings":"","what":"eaf 2.0","title":"eaf 2.0","text":"CRAN release: 2021-02-08 read_datasets() able read files compressed xz. eafs() eafdiff() plotting functions using now consume slightly less memory. New function whv_hype() estimate weighted hypervolume using Monte-Carlo sampling. New functions total_whv_rect() whv_rect() compute weighted hypervolume rectangular weighted regions. New functions largest_eafdiff(), choose_eafdiffplot() choose_eafdiff() converting EAF differences weighted regions calculating weighted hypervolume. New function avg_hausdorff_dist() computing averaged Hausdorff distance.","code":""},{"path":"/news/index.html","id":"eaf-19-1","dir":"Changelog","previous_headings":"","what":"eaf 1.9-1","title":"eaf 1.9-1","text":"CRAN release: 2020-03-05 Fixes Makefiles non-GCC compilers parallel build setups.","code":""},{"path":"/news/index.html","id":"eaf-19","dir":"Changelog","previous_headings":"","what":"eaf 1.9","title":"eaf 1.9","text":"CRAN release: 2020-03-03 Compute Vorob’ev threshold, expectation deviation. Plots symmetric deviation. (Mickael Binois) Non-integer EAF percentiles computed correctly. Various aesthetic improvements eafplot() eafdiffplot(). Functions computing hypervolume, hypervolume contributions, epsilon metric, IGD+, filter dominated points, fast normalisation ranges. Command-line tools computing installed system.file(package=\"eaf\", \"bin/\"). Online documentation available : http://lopez-ibanez.eu/eaftools New read_datasets() replaces deprecated read.data.sets(). New parameter text read_datasets(). New eafdiff() function computing EAF differences. data.frame method eafplot removed. unexpected behavior default method handles data.frame already. Python script compute EAF differences installed system.file(package=\"eaf\", \"scripts/eafdiff.py\").","code":""},{"path":"/news/index.html","id":"eaf-18","dir":"Changelog","previous_headings":"","what":"eaf 1.8","title":"eaf 1.8","text":"CRAN release: 2018-03-22 Development version moved GitHub: https://github.com/MLopez-Ibanez/eaf Remove leading zeros version number. New parameters left.panel.last right.panel.last eafdiffplot(). Export document function eafs() compute EAFs. eafdiff.pl: Handle --colors=, --intervals=. Fix crash eafplot() sets vector strings. Reset layout eafdiffplot(). Compute eaf 3D. Added testthat testing framework. documentation now generated Roxygen2. Entry points C code now properly registered.","code":""},{"path":"/news/index.html","id":"eaf-107","dir":"Changelog","previous_headings":"","what":"eaf 1.07","title":"eaf 1.07","text":"CRAN release: 2015-01-07 Silence CRAN warning GNU extensions Makefiles inst/scripts/eaf/Makefile.","code":""},{"path":"/news/index.html","id":"eaf-106","dir":"Changelog","previous_headings":"","what":"eaf 1.06","title":"eaf 1.06","text":"CRAN release: 2014-10-01 Fix bug automatically generating legend eafplot formula interface (Thanks Bernd Bischl reporting ) Improve handling various newline character formats. Reduce memory consumption (four times less memory). eafdiff.pl: Mention option --legendpos=none hide legend. eafplot.pl: Add options --maximise --xmaximise --colors=. Fix bug --area. eafplot.default() now requires two colors type==\"area\" palette interpolated two colors different levels plotted (Thanks Alexandre Quemy suggestion).","code":""},{"path":"/news/index.html","id":"eaf-105","dir":"Changelog","previous_headings":"","what":"eaf 1.05","title":"eaf 1.05","text":"CRAN release: 2013-02-20 Implement type = \"area\" eafdiffplot(). now default. idea algorithm compute areas provided Carlos M. Fonseca. implementation uses R polygons, PDF viewers may trouble rendering correctly (See https://cran.r-project.org/doc/FAQ/R-FAQ.html#---unwanted-borders). Plots look correct printed. get previous behavior use eafdiffplot(, type = \"point\"). Attempt deal DOS/Unix newlines correctly. eafplot.pl: Cleanups. (--single, --output, --legend): New options. Default PDF. eafdiff.pl: Many cleanups. EAF diff type=\"area\" default now. Parameter --cex replaced --scale. require ps2eps. Handle --obj1= better. Crop pdf converting png. (--noattsurfs): New option. (--output-dir,--output): New options. (--eps): New option. PDF default now. Force eafdiff plots use square plotting region. read.data.sets() normalizes paths, thus works files ~/file. Function eafdiffplot() handles percentiles=NA grand.lines parameter. Fix bug ranges maximise=TRUE eafdiffplot(). Fix points.steps work correctly values maximise. Fix bug eafdiffplot(..., maximise=c(TRUE,FALSE), full.eaf = TRUE) Fix \"log\" parameter eafplot eafdiffplot. Avoid eafplot.formula modifies global options. Add 'axes' parameter eafplot. avoid confusion, arguments 'xaxis.side' 'yaxis.side' eafplot can take values c(\"\", \"\") c(\"left\",   \"right\"), respectively. Add missing Makefile inst/scripts/eaf/.","code":""},{"path":"/news/index.html","id":"eaf-104","dir":"Changelog","previous_headings":"","what":"eaf 1.04","title":"eaf 1.04","text":"CRAN release: 2012-01-10 Fix issues one point EAF.","code":""},{"path":"/news/index.html","id":"eaf-103","dir":"Changelog","previous_headings":"","what":"eaf 1.03","title":"eaf 1.03","text":"CRAN release: 2011-12-04 Handle maximise argument eafdiffplot --maximise command-line option eafdiff.pl R/calls.R (eafplot.data.frame): Fix problem main parameter.","code":""},{"path":"/news/index.html","id":"eaf-100","dir":"Changelog","previous_headings":"","what":"eaf 1.00","title":"eaf 1.00","text":"Initial release available CRAN.","code":""}]
